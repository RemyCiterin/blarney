:source-highlighter:

++++
<br/>
++++

image::blarney-logo.svg#gh-light-mode-only[Blarney logo, width=275]
image::blarney-logo-dark.svg#gh-dark-mode-only[Blarney logo, width=275]

++++
<br/>
++++

Blarney is a Haskell library for hardware description that builds a
range of HDL abstractions on top of a small set of pure functional
circuit primitives.  It is a modern variant of
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.110.5587&rep=rep1&type=pdf[Lava]
using many of the latest features of GHC.  Some aspects of the library
are also inspired by https://github.com/B-Lang-org/bsc[Bluespec], such
as first-class actions and method-based interfaces.

== Prerequisites

We'll need Verilator and GHC 9.2.1 or later.

On Ubuntu 20.04, we can do:

[source, shell]
----
$ sudo apt install verilator libgmp-dev
----

For GHC 9.2.1 or later, https://www.haskell.org/ghcup/[ghcup] can be
used.

== Quick start

To clone the repo:

[source, shell]
----
$ git clone --recursive https://github.com/blarney-lang/blarney
----

To simulate the
https://github.com/blarney-lang/blarney/tree/master/Examples/Sorter/Sorter.hs[Sorter]
example from Blarney's
https://github.com/blarney-lang/blarney/tree/master/Examples[Examples]
directory:

[source, shell]
----
$ cd blarney/Examples/Sorter
$ make                  # Build the example using GHC
$ ./Sorter              # Generate Verilog for the example
$ cd Sorter-Verilog     # Go to the generated Verilog
$ make                  # Compile the generated Verilog using Verilator
$ ./Sorter              # Simulate the generated Verilog
----

You should see the output:

----
sort [3,4,1,0,2] = [0,1,2,3,4]
----

To run the regression test suite:

[source, shell]
----
$ cd blarney/Test
$ ./test.sh --run-all
----

To start development of your own Blarney application or library, take
a look at the
https://github.com/blarney-lang/template-project/[Blarney template project].

== Taster

Like Haskell, Blarney's main strength is support for writing clear,
modular, strongly typed code.  To get a feel for this, we will briefly
demonstrate how to implement a _server farm_ in Blarney.

The concept of a server (or slave) is commonly used in hardware design
to capture the idea of a module that consumes requests and produces
responses.  In Blarney, it can be modelled as a function over streams:

[source, haskell]
----
type Server req resp = Stream req -> Module (Stream resp)
----

Some servers take longer than others to process requests. For example,
a divider server that implements division by repeated substraction,
and which is only able to process one request at a time, would be very
slow: if it took _n_ cycles to perform a division on average, the
server's throughput would be _1/n_ requests per cycle.  The idea of a
server farm is that if you instantiate _n_ such servers, you can
obtain a new server with a average throughput of 1 request per cycle.
So a server farm is a function from a server to a server:

[source, haskell]
----
makeServerFarm :: Interface resp => Int -> Server req resp -> Server req resp
makeServerFarm n server reqs =
  splitStream n reqs >>= mapM server >>= mergeStreams
----

The first stage of our server farm splits the request stream into _n_
streams, forwarding requests to each stream in a round-robin fashion.
Each stream is then passed through an instance of the server.
Finally, the response streams are merged using the same round-robin
strategy that was used to split the request streams, thereby keeping
responses in order with respect to their corresponding requests.

To implement the splitting stage, we need to keep track of the next
server to feed. For this, we use a _n_-element list of 1-bit
registers, the first of which is initialised to true, and the others
to false.  When the next scheduled server consumes a request, we
rotate the values of the registers so that a different server is fed
next.

[source, haskell]
----
splitStream :: Int -> Stream a -> Module [Stream a]
splitStream n s = do
  -- Which output stream to feed next?
  next :: [Reg (Bit 1)] <-
    mapM makeReg ([true] ++ replicate (n-1) false)

  -- When an output stream is consumed, move to the next one
  return
    [ s {
        canPeek = s.canPeek .&&. active.val
      , consume = s.consume >> rotate next
      }
    | active <- next ]
----

To rotate the values of the registers, we use the following helper
function.

[source, haskell]
----
rotate :: Bits a => [Reg a] -> Action ()
rotate xs = zipWithM_ (<==) xs (drop 1 vals ++ take 1 vals)
  where vals = map (.val) xs
----

To implement the merging stage, we track the next server to consume
from using the same bit rotation strategy as the splitting stage.  We
then use this one-hot bit mask as an index into the list of response
streams.

[source, haskell]
----
mergeStreams :: Interface a => [Stream a] -> Module (Stream a)
mergeStreams ss = do
  -- Which input stream to consume next?
  next :: [Reg (Bit 1)] <-
    mapM makeReg ([true] ++ replicate (length ss - 1) false)

  -- Select stream using general indexing operator
  let s = ss ! OneHotList (map (.val) next)

  -- When output is consumed, move to the next input stream
  return
    s { consume = s.consume >> rotate next }
----

This concludes the definition of the server farm. To see it in action,
take a look at the
https://github.com/blarney-lang/blarney/tree/master/Examples/GCDFarm/GCDFarm.hs[GCD
farm example].  The biggest weakness of this implementation is that it
must produce responses in order, even if later responses become
available before earlier ones.  An interesting exercise might be to
develop a server farm that supports out-of-order responses.

== Applications

Our current list of applications developed using Blarney:

* https://github.com/blarney-lang/actora/[Actora]: A 3-stage stack
processor that runs code written a subset of Erlang. It has higher
performance density than Intel's register-based NIOS-II core for
compiled Erlang code.

* https://github.com/CTSRD-CHERI/SIMTight/[SIMTight]: A
https://cheri-cpu.org[CHERI]-enabled
RISC-V GPGPU with dynamic scalarisation features and high performance
density on Intel's Stratix 10 FPGA.

== Documentation

See
https://github.com/blarney-lang/blarney/blob/master/Doc/ByExample.adoc[Blarney
by Example], our introduction to Blarney, which supplements the
http://blarney-lang.github.io/blarney/index.html[Haddock docs].
